{-# LANGUAGE DuplicateRecordFields #-}

module DBFTP (UploadState(..), traverseDirectories, uploadFile) where

import Control.Exception (assert)
import Control.Monad.Loops (unfoldWhileM)
import qualified Data.ByteString.Char8 as S8
import qualified Data.ByteString.Lazy as BL
import Data.Aeson
import Data.Function ((&))
import qualified Data.HashMap.Strict as H
import Data.Maybe
import qualified Data.Text as T
import qualified Data.Vector as V
import Data.Word
import Network.HTTP.Client hiding (fileSize)
import Network.HTTP.Client.TLS
import Network.HTTP.Simple
import Streamly
import qualified Streamly.Prelude as S
import System.FilePath.Posix
import System.Posix



data UploadState = UploadState { sourcePath :: FilePath
                               , sourceSize :: Maybe Word64
                               , destPath :: Maybe FilePath
                               , sessionId :: Maybe String
                               , offset :: Maybe Word64
                               }
  deriving (Eq, Ord, Read, Show)



-- -- | Recursively expand directories into a list of file names
-- listFiles :: [FilePath] -> IO [FilePath]
-- listFiles = concatMapM listFile
-- 
-- listFile :: FilePath -> IO [FilePath]
-- listFile fp = do let fn = takeFileName fp
--                  if fn == "." || fn == ".."
--                    then return []
--                    else do fs <- getFileStatus fp
--                            if | isRegularFile fs -> return [fp]
--                               | isDirectory fs -> do fps' <- listDir fp
--                                                      listFiles fps'
--                               | True -> return []
-- 
-- listDir :: FilePath -> IO [FilePath]
-- listDir dp = do ds <- openDirStream dp
--                 fps <- unfoldWhileM (not . null) (readDirStream ds)
--                 closeDirStream ds
--                 return $ (dp </>) <$> fps



-- | Recursively expand directories into a stream of file names
traverseDirectories :: Serial FilePath -> Serial UploadState
traverseDirectories = S.concatMap traverseEntry

traverseEntry :: FilePath -> Serial UploadState
traverseEntry fp =
  let fn = takeFileName fp
  in if fn == "." || fn == ".."
     then S.nil
     else do fs <- S.yieldM (getFileStatus fp)
             if | isRegularFile fs -> S.yield (UploadState fp (Just $ fromIntegral $ fileSize fs) Nothing Nothing Nothing)
                | isDirectory fs -> traverseDirectories (readDir fp)
                | True -> S.nil

readDir :: FilePath -> Serial FilePath
readDir = fromStreamList . S.yieldM . listDir
  where listDir :: FilePath -> IO [FilePath]
        listDir dp = do ds <- openDirStream dp
                        fps <- unfoldWhileM (not . null) (readDirStream ds)
                        closeDirStream ds
                        return $ (dp </>) <$> fps

fromStreamList :: Serial [a] -> Serial a
fromStreamList = S.concatMap S.fromList



-- https://www.dropbox.com/developers/documentation/http/overview



-- data UploadSessionStartArg =
--   UploadSessionStartArg { close :: Bool }
--   deriving (Eq, Ord, Read, Show)
-- instance FromJSON UploadSessionStartArg where
--   parseJSON (Object v) = UploadSessionStartArg <$>
--                          v .: "close"
--   parseJSON _ = mzero
-- instance ToJSON UploadSessionStartArg where
--   toJSON UploadSessionStartArg{..} = object ["close" .= close]

-- uploadFile :: Serial FilePath -> Serial Upload
uploadFile :: UploadState -> IO UploadState
uploadFile upload =
  do authToken <- getAuthToken
     manager <- newManager tlsManagerSettings
     let fp = sourcePath upload
     let fs = fromJust (sourceSize upload)
     -- let args = UploadSessionStartArg { close = True }
     let args = object [ "close" .= True ]
     let request =
           defaultRequest
           & setRequestManager manager
           & setRequestSecure True
           & setRequestHost "content.dropboxapi.com"
           & setRequestPort 443
           & setRequestMethod "POST"
           & setRequestPath "/2/files/upload_session/start"
           & setRequestHeader "Authorization" [S8.append "Bearer " authToken]
           & setRequestHeader "Dropbox-API-Arg" [BL.toStrict (encode args)]
           & setRequestHeader "Content-Type" ["application/octet-stream"]
           & setRequestBodyFile fp
     response <- httpJSON request
     assertM $ getResponseStatusCode response == 200
     assertM $ getResponseHeader "Content-Type" response == ["application/json"]
     let sessionId = case getResponseBody response :: Value of
                       Object obj -> case obj H.! "session_id" of
                         String str -> T.unpack str
     return $ upload { sessionId = Just sessionId
                     , offset = Just fs
                     }



-- data UploadSessionFinishBatchArg =
--   UploadSessionFinishBatchArg [UploadSessionFinishArg]
--   deriving (Eq, Ord, Read, Show)
-- instance ToJSON UploadSessionFinishBatchArg where
--   toJSON (UploadSessionFinishBatchArg elts) =
--     Array $ V.fromList $ toJSON <$> elts
-- 
-- data UploadSessionFinishArg =
--   UploadSessionFinishArg { cursor :: UploadSessionCursor
--                          , commitInfo :: CommitInfo
--                          }
--   deriving (Eq, Ord, Read, Show)
-- instance ToJSON UploadSessionFinishArg where
--   toJSON UploadSessionFinishArg{..} =
--     object [ "cursor" .= cursor
--            , "commit_info" .= commitInfo
--            ]
-- 
-- data UploadSessionCursor =
--   UploadSessionCursor { sessionId :: String
--                       , offset :: Word64 }
--   deriving (Eq, Ord, Read, Show)
-- instance ToJSON UploadSessionCursor where
--   toJSON UploadSessionCursor{..} =
--     object [ "session_id" .= sessionId
--            , "offset" .= offset
--            ]
-- 
-- data CommitInfo =
--   CommitInfo { path :: String
--              , mode :: WriteMode
--              , autorename :: Bool
--              , clientModified :: Timestamp
--              , mute :: Bool
--              , propertyGroups :: Maybe [PropertyGroup]
--              , strictConflict :: Bool
--              }
--   deriving (Eq, Ord, Read, Show)
-- instance ToJSON CommitInfo where
--   toJSON CommitInfo{..} =
--     object [ "path" .= path
--            , "mode" .= mode
--            , "autorename" .= autorename
--            , "client_modified" .= clientModified
--            , "mute" .= mute
--            -- , "propertyGroups" .= propertyGroups
--            , "strict_conflict" .= strictConflict
--            ]
--            
-- data WriteMode = Add
--                | Overwrite
--                | Update String
--   deriving (Eq, Ord, Read, Show)
-- instance ToJSON WriteMode where
--   toJSON Add = String "add"
--   toJSON Overwrite = String "overwrite"
--   toJSON (Update str) = String (T.pack ("update " ++ str))
-- 
-- type PropertyGroup = () -- TODO
-- type Timestamp = String

uploadMetadata :: [UploadState] -> IO [UploadState]
uploadMetadata uploads =
  do authToken <- getAuthToken
     manager <- newManager tlsManagerSettings
     let args = object ["entries" .= (V.fromList [ object [ "cursor" .= object [ "session_id" .= sessionId upload
                                                                               , "offset" .= offset upload
                                                                               ]
                                                          , "commit" .= object [ "path" .= destPath upload
                                                                               ]
                                                          ]
                                                 | upload <- uploads
                                                 ])
                       ]
     let request =
           defaultRequest
           & setRequestManager manager
           & setRequestSecure True
           & setRequestHost "api.dropboxapi.com"
           & setRequestPort 443
           & setRequestMethod "POST"
           & setRequestPath "/2/files/upload_session/finish_batch"
           & setRequestHeader "Authorization" [S8.append "Bearer " authToken]
           & setRequestHeader "Content-Type" ["application/json"]
           & setRequestBodyJSON args
     response <- httpJSON request
     assertM $ getResponseStatusCode response == 200
     assertM $ getResponseHeader "Content-Type" response == ["application/json"]
     let tag = case getResponseBody response :: Value of
                 Object obj -> case obj H.! ".tag" of
                   String str -> T.unpack str
     return []



getAuthToken :: IO S8.ByteString
getAuthToken = parseToken <$> S8.pack <$> readFile "/Users/eschnett/.dbftp.http"

parseToken :: S8.ByteString -> S8.ByteString
parseToken s = chomp $ S8.drop (S8.length "access_token:") s
  


chomp :: S8.ByteString -> S8.ByteString
chomp s = if S8.null s || S8.last s /= '\n'
          then s
          else S8.init s

assertM :: Applicative m => Bool -> m ()
assertM c = assert c $ pure ()
